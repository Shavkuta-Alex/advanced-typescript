<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced TypeScript Learning Guide</title>
  <style>
    code[class*="language-"],pre[class*="language-"]{color:#ccc;background:none;font-family:'Fira Code',Consolas,Monaco,monospace;font-size:.9em;text-align:left;white-space:pre;line-height:1.5;tab-size:2}
    pre[class*="language-"]{padding:1em;margin:1.5rem 0;overflow:auto;border-radius:8px;background:#2d2d2d}
    .token.comment{color:#999}.token.punctuation{color:#ccc}.token.tag,.token.attr-name,.token.deleted{color:#e2777a}.token.function-name{color:#6196cc}.token.boolean,.token.number,.token.function{color:#f08d49}.token.property,.token.class-name,.token.constant,.token.symbol{color:#f8c555}.token.keyword,.token.builtin{color:#cc99cd}.token.string,.token.char,.token.attr-value,.token.regex,.token.variable{color:#7ec699}.token.operator,.token.entity,.token.url{color:#67cdcc}
    :root{--bg:#fff;--bg2:#f8f9fa;--text:#1a1a2e;--text2:#4a4a6a;--accent:#3b82f6;--accent-light:#dbeafe;--border:#e5e7eb}
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:'Segoe UI',system-ui,sans-serif;line-height:1.7;color:var(--text);background:var(--bg);font-size:16px}
    .container{max-width:900px;margin:0 auto;padding:2rem}
    .title-page{text-align:center;padding:6rem 2rem;background:linear-gradient(135deg,#1a1a2e,#16213e);color:#fff;margin-bottom:3rem}
    .title-page h1{font-size:3.5rem;font-weight:700;margin-bottom:.5rem}
    .title-page .subtitle{font-size:2rem;font-weight:300;opacity:.9;margin-bottom:2rem}
    .title-page .tagline{font-size:1.1rem;opacity:.7;max-width:600px;margin:0 auto}
    .toc{background:var(--bg2);padding:2rem;border-radius:12px;margin-bottom:3rem}
    .toc h2{font-size:1.5rem;margin-bottom:1.5rem}
    .toc-list{list-style:none;display:grid;gap:.75rem}
    .toc-list a{color:var(--accent);text-decoration:none;display:flex;align-items:center;gap:.75rem;padding:.5rem 0;border-bottom:1px solid var(--border)}
    .toc-list a:hover{color:#1d4ed8}
    .toc-list .num{background:var(--accent);color:#fff;width:28px;height:28px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:.85rem;font-weight:600}
    .intro{margin-bottom:4rem;padding-bottom:2rem;border-bottom:2px solid var(--border)}
    .intro h2{font-size:2rem;margin-bottom:1.5rem}
    .intro p{margin-bottom:1rem;color:var(--text2)}
    .intro ol{margin-left:1.5rem;color:var(--text2)}
    .intro li{margin-bottom:.5rem}
    .topic{margin-bottom:4rem;padding-bottom:3rem;border-bottom:1px solid var(--border)}
    .topic:last-of-type{border-bottom:none}
    .topic h2{font-size:1.75rem;margin-bottom:.75rem}
    .meta{display:flex;gap:1.5rem;flex-wrap:wrap;font-size:.9rem;margin-bottom:1.5rem}
    .badge{background:var(--accent-light);color:var(--accent);padding:.25rem .75rem;border-radius:20px;font-weight:500}
    .badge.expert{background:#fef3c7;color:#d97706}
    .badge.advanced{background:#fee2e2;color:#dc2626}
    .topic h3{font-size:1.25rem;margin:2rem 0 1rem;padding-bottom:.5rem;border-bottom:2px solid var(--accent-light)}
    .topic p{color:var(--text2);margin-bottom:1rem}
    .topic ul{list-style:none;margin-bottom:1.5rem}
    .topic ul li{position:relative;padding-left:1.5rem;margin-bottom:.6rem;color:var(--text2)}
    .topic ul li::before{content:"‚Üí";position:absolute;left:0;color:var(--accent);font-weight:700}
    :not(pre)>code{background:var(--bg2);padding:.2rem .4rem;border-radius:4px;font-family:'Fira Code',monospace;font-size:.9em;color:#e83e8c}
    .resources{background:var(--bg2);border-radius:8px;padding:1.5rem;margin-top:1.5rem}
    .resources h4{font-size:1rem;margin-bottom:1rem}
    .res-list{list-style:none}
    .res-list li{margin-bottom:1rem;padding-bottom:1rem;border-bottom:1px solid var(--border)}
    .res-list li:last-child{margin-bottom:0;padding-bottom:0;border-bottom:none}
    .res-list a{color:var(--accent);text-decoration:none;font-weight:600}
    .res-list .desc{display:block;font-size:.9rem;color:var(--text2);margin-top:.25rem}
    .exercises{background:linear-gradient(135deg,#065f46,#047857);border-radius:8px;padding:1.5rem;margin-top:1.5rem;color:#fff}
    .exercises h4{font-size:1rem;margin-bottom:1rem;color:#fff}
    .exercises ul{list-style:none}
    .exercises li{margin-bottom:.75rem;padding-left:0}
    .exercises li::before{content:""}
    .exercises a{color:#6ee7b7;text-decoration:none;font-weight:600}
    .exercises a:hover{color:#a7f3d0;text-decoration:underline}
    .exercises .ex-diff{font-size:.75rem;padding:.15rem .5rem;border-radius:10px;margin-left:.5rem;font-weight:500}
    .exercises .ex-easy{background:#d1fae5;color:#065f46}
    .exercises .ex-medium{background:#fef3c7;color:#92400e}
    .exercises .ex-hard{background:#fee2e2;color:#991b1b}
    .exercises .ex-extreme{background:#f3e8ff;color:#6b21a8}
    .exercises .ex-src{font-size:.8rem;opacity:.8;margin-left:.25rem}
    .quick-ref{background:linear-gradient(135deg,#1a1a2e,#16213e);color:#fff;padding:3rem 2rem;border-radius:12px;margin-top:3rem}
    .quick-ref h2{font-size:1.75rem;margin-bottom:1.5rem}
    .quick-ref ul{list-style:none;display:grid;gap:1rem}
    .quick-ref li{display:flex;gap:1rem;align-items:flex-start}
    .quick-ref .icon{background:rgba(255,255,255,.1);padding:.5rem;border-radius:8px}
    .quick-ref a{color:#93c5fd;text-decoration:none}
    .quick-ref .title{font-weight:600;display:block}
    .quick-ref .url{font-size:.85rem;opacity:.7}
    .code-wrapper{position:relative}
    .copy-btn{position:absolute;top:8px;right:8px;background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);color:#ccc;padding:6px 10px;border-radius:6px;cursor:pointer;font-size:12px;font-family:system-ui,sans-serif;display:flex;align-items:center;gap:5px;transition:all 0.2s;z-index:10}
    .copy-btn:hover{background:rgba(255,255,255,0.2);color:#fff}
    .copy-btn.copied{background:#10b981;border-color:#10b981;color:#fff}
    .copy-btn svg{width:14px;height:14px}
  </style>
</head>
<body>
  <div class="title-page">
    <h1>Advanced TypeScript</h1>
    <div class="subtitle">Learning Guide</div>
    <p class="tagline">20 essential topics ordered for optimal learning ‚Äî each building on previous concepts</p>
  </div>
  
  <div class="container">
    <nav class="toc">
      <h2>Table of Contents</h2>
      <ol class="toc-list">
        <li><a href="#t1"><span class="num">1</span> Discriminated Unions and Exhaustiveness</a></li>
        <li><a href="#t2"><span class="num">2</span> satisfies and const Assertions</a></li>
        <li><a href="#t3"><span class="num">3</span> Advanced Infer Patterns and Positions</a></li>
        <li><a href="#t4"><span class="num">4</span> Distributive Conditional Types</a></li>
        <li><a href="#t5"><span class="num">5</span> Tuple Manipulation</a></li>
        <li><a href="#t6"><span class="num">6</span> Template Literal Types</a></li>
        <li><a href="#t7"><span class="num">7</span> Mapped Type Key Remapping</a></li>
        <li><a href="#t8"><span class="num">8</span> Recursive Conditional Types</a></li>
        <li><a href="#t9"><span class="num">9</span> Variance and Contravariance</a></li>
        <li><a href="#t10"><span class="num">10</span> Union to Intersection Conversion</a></li>
        <li><a href="#t11"><span class="num">11</span> Declaration Merging</a></li>
        <li><a href="#t12"><span class="num">12</span> Advanced Module and Namespace Patterns</a></li>
        <li><a href="#t13"><span class="num">13</span> Branded Types (Nominal Typing)</a></li>
        <li><a href="#t14"><span class="num">14</span> Type-Safe Builder Pattern</a></li>
        <li><a href="#t15"><span class="num">15</span> Deep Path Types and Dot Notation Access</a></li>
        <li><a href="#t16"><span class="num">16</span> Type-Safe State Machines</a></li>
        <li><a href="#t17"><span class="num">17</span> Type-Level Arithmetic</a></li>
        <li><a href="#t18"><span class="num">18</span> Currying and Function Composition Types</a></li>
        <li><a href="#t19"><span class="num">19</span> Higher-Kinded Type (HKT) Simulation</a></li>
        <li><a href="#t20"><span class="num">20</span> Type-Level JSON Parsing</a></li>
      </ol>
    </nav>
    
    <section class="intro">
      <h2>Introduction</h2>
      <p>This guide covers 20 advanced TypeScript type-system features, <strong>ordered by prerequisite dependencies</strong>. Each topic builds on concepts from previous ones, creating an optimal learning path from foundational patterns to expert-level type gymnastics.</p>
      <h3 style="font-size:1.1rem;margin:1.5rem 0 1rem">How to Use This Guide</h3>
      <ol>
        <li>Work through topics in order ‚Äî each builds on previous concepts</li>
        <li>Study code examples in the TypeScript Playground</li>
        <li>Complete Type Challenges for hands-on practice</li>
        <li>Revisit earlier topics when prerequisites are mentioned</li>
      </ol>
    </section>

    <article class="topic" id="t1">
      <h2>1. Discriminated Unions and Exhaustiveness</h2>
      <div class="meta"><span><strong>Difficulty:</strong> <span class="badge">Upper Intermediate</span></span><span><strong>Prerequisites:</strong> Union types, type narrowing, never type</span></div>
      <h3>Overview</h3>
      <p>Discriminated unions (tagged unions) use a common property to distinguish between variants, enabling TypeScript to narrow types in control flow. This is the foundation for modeling domain logic, API responses, Redux-style actions, and state machines. Master this first ‚Äî it's used throughout advanced TypeScript patterns.</p>
      <h3>Key Concepts</h3>
      <ul>
        <li>Single and multiple discriminant properties</li>
        <li>Exhaustiveness checking with the never type</li>
        <li>Extracting and manipulating union variants</li>
        <li>Narrowing with in operator, typeof, and instanceof</li>
        <li>Nested discriminated unions for complex state</li>
        <li>Generic discriminated union factories</li>
      </ul>
      <h3>Code Example</h3>
      <pre><code class="language-typescript">// Basic discriminated union
type Result&lt;T, E = Error&gt; =
  | { ok: true; value: T }
  | { ok: false; error: E };

function handleResult&lt;T&gt;(result: Result&lt;T&gt;) {
  if (result.ok) {
    console.log(result.value);  // TS knows value exists
  } else {
    console.error(result.error); // TS knows error exists
  }
}

// EXHAUSTIVENESS CHECKING with never
type Action =
  | { type: 'INCREMENT'; amount: number }
  | { type: 'DECREMENT'; amount: number }
  | { type: 'RESET' };

function assertNever(x: never): never {
  throw new Error(`Unexpected: ${JSON.stringify(x)}`);
}

function reducer(state: number, action: Action): number {
  switch (action.type) {
    case 'INCREMENT': return state + action.amount;
    case 'DECREMENT': return state - action.amount;
    case 'RESET': return 0;
    default: return assertNever(action); // Error if case missing!
  }
}

// EXTRACT UNION VARIANTS
type ExtractVariant&lt;U, T&gt; = U extends { type: T } ? U : never;
type IncrementAction = ExtractVariant&lt;Action, 'INCREMENT'&gt;;

// GENERATE DISCRIMINATED UNION FROM CONFIG
type EventConfig = { click: { x: number; y: number }; keypress: { key: string } };
type Event = { [K in keyof EventConfig]: { type: K } &amp; EventConfig[K] }[keyof EventConfig];</code></pre>
      <div class="resources"><h4>üìö Learning Resources</h4><ul class="res-list">
        <li><a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions">TypeScript Handbook - Discriminated Unions</a><span class="desc">Official documentation</span></li>
        <li><a href="https://github.com/gvergnaud/ts-pattern">ts-pattern</a><span class="desc">Exhaustive pattern matching library</span></li>
        <li><a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#exhaustiveness-checking">Exhaustiveness Checking</a><span class="desc">Never type for completeness</span></li>
      </ul></div>
      <div class="exercises"><h4>üèãÔ∏è Hands-On Exercises</h4><ul>
        <li><a href="https://typehero.dev/challenge/literal-types">Literal Types</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/union-types">Union Types</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/type-narrowing">Type Narrowing</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/discriminated-union">Discriminated Union</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00004-easy-pick/README.md">Pick</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00043-easy-exclude/README.md">Exclude</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">Type Challenges</span></li>
      </ul></div>
    </article>

    <article class="topic" id="t2">
      <h2>2. satisfies Operator and const Assertions</h2>
      <div class="meta"><span><strong>Difficulty:</strong> <span class="badge">Upper Intermediate</span></span><span><strong>Prerequisites:</strong> Type inference, literal types, readonly types</span></div>
      <h3>Overview</h3>
      <p>The <code>satisfies</code> operator (TS 4.9+) and <code>as const</code> assertions are essential modern TypeScript tools. While <code>as const</code> creates the narrowest possible literal type, <code>satisfies</code> validates against a type without widening. Together they enable precise typing of configuration objects while preserving full literal type information.</p>
      <h3>Key Concepts</h3>
      <ul>
        <li><code>as const</code> creates deeply readonly types with literal values</li>
        <li><code>satisfies</code> checks type compatibility without changing the inferred type</li>
        <li>Combining both for validated literal configurations</li>
        <li>Preserving string literal keys while ensuring value types</li>
        <li>Type-safe exhaustive objects with known keys</li>
      </ul>
      <h3>Code Example</h3>
      <pre><code class="language-typescript">// WITHOUT satisfies - type annotation widens
const colors1: Record&lt;string, [number, number, number]&gt; = {
  red: [255, 0, 0], green: [0, 255, 0],
};
colors1.typo; // No error - any string key allowed!

// WITH satisfies - validates but preserves literal types
const colors2 = {
  red: [255, 0, 0], green: [0, 255, 0],
} satisfies Record&lt;string, [number, number, number]&gt;;
colors2.red;   // Type is [255, 0, 0] - literal preserved!
colors2.typo;  // Error! Only 'red' | 'green' allowed

// as const for deepest literal type
const routes = { home: '/', users: '/users' } as const;
type RouteValues = typeof routes[keyof typeof routes]; // '/' | '/users'

// COMBINING BOTH for ultimate control
const apiRoutes = {
  getUsers: '/api/users',
  getUser: '/api/users/:id',
} as const satisfies Record&lt;string, `/${string}`&gt;;
// Validates AND preserves literal types!</code></pre>
      <div class="resources"><h4>üìö Learning Resources</h4><ul class="res-list">
        <li><a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#the-satisfies-operator">TypeScript 4.9 - satisfies</a><span class="desc">Official release notes</span></li>
        <li><a href="https://www.totaltypescript.com/clarifying-the-satisfies-operator">Total TypeScript - satisfies</a><span class="desc">Matt Pocock's deep dive</span></li>
      </ul></div>
      <div class="exercises"><h4>üèãÔ∏è Hands-On Exercises</h4><ul>
        <li><a href="https://typehero.dev/challenge/readonly">Readonly</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/typeof">Typeof</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/indexed-access">Indexed Access Types</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00007-easy-readonly/README.md">Readonly</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://www.totaltypescript.com/workshops/type-transformations/type-helpers/constrain-a-type-helper-to-only-accept-strings">Constrain Type Helpers</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Total TypeScript</span></li>
      </ul></div>
    </article>

    <article class="topic" id="t3">
      <h2>3. Advanced Infer Patterns and Positions</h2>
      <div class="meta"><span><strong>Difficulty:</strong> <span class="badge advanced">Advanced</span></span><span><strong>Prerequisites:</strong> Conditional types, basic infer usage, function types, variance</span></div>
      <h3>Overview</h3>
      <p>The <code>infer</code> keyword is TypeScript's most powerful type extraction tool, but its behavior changes dramatically based on position (covariant vs contravariant). Mastering advanced infer patterns unlocks the ability to extract types from complex structures and understand why certain patterns produce unions vs intersections.</p>
      <h3>Key Concepts</h3>
      <ul>
        <li>Covariant positions (return types): multiple infers produce unions</li>
        <li>Contravariant positions (parameters): multiple infers produce intersections</li>
        <li>Using <code>infer X extends Constraint</code> for constrained inference (TS 4.7+)</li>
        <li>Inferring in template literal types for string parsing</li>
        <li>Variadic tuple infer: [...infer Head, infer Last]</li>
      </ul>
      <h3>Code Example</h3>
      <pre><code class="language-typescript">// COVARIANT - produces UNION
type Returns&lt;T&gt; = T extends { a: () =&gt; infer R } | { b: () =&gt; infer R } ? R : never;
type RU = Returns&lt;{ a: () =&gt; string } | { b: () =&gt; number }&gt;; // string | number

// CONTRAVARIANT - produces INTERSECTION
type Params&lt;T&gt; = T extends { a: (x: infer P) =&gt; void } | { b: (x: infer P) =&gt; void } ? P : never;
type PI = Params&lt;{ a: (x: { foo: 1 }) =&gt; void } | { b: (x: { bar: 2 }) =&gt; void }&gt;; 
// { foo: 1 } &amp; { bar: 2 }

// CONSTRAINED INFER (TS 4.7+)
type FirstStr&lt;T&gt; = T extends [infer S extends string, ...any[]] ? S : never;
type F = FirstStr&lt;['hi', 42]&gt;; // 'hi'

// VARIADIC TUPLE INFER
type Last&lt;T extends any[]&gt; = T extends [...any[], infer L] ? L : never;
type L = Last&lt;[1, 2, 3]&gt;; // 3

// TEMPLATE LITERAL INFER
type ParseRoute&lt;T&gt; = T extends `/${infer Seg}/${infer Rest}`
  ? [Seg, ...ParseRoute&lt;`/${Rest}`&gt;]
  : T extends `/${infer Seg}` ? [Seg] : [];
type Segments = ParseRoute&lt;'/users/123/posts'&gt;; // ['users', '123', 'posts']</code></pre>
      <div class="resources"><h4>üìö Learning Resources</h4><ul class="res-list">
        <li><a href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types">TypeScript Handbook - Infer</a><span class="desc">Official documentation</span></li>
        <li><a href="https://type-level-typescript.com">Type-Level TypeScript</a><span class="desc">In-depth infer coverage</span></li>
      </ul></div>
      <div class="exercises"><h4>üèãÔ∏è Hands-On Exercises</h4><ul>
        <li><a href="https://typehero.dev/challenge/infer">Infer</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/return-type">ReturnType</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/parameters">Parameters</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/awaited">Awaited</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00002-medium-return-type/README.md">Get Return Type</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/03312-easy-parameters/README.md">Parameters</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00189-easy-awaited/README.md">Awaited</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/03192-medium-reverse/README.md">Reverse</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
      </ul></div>
    </article>

    <article class="topic" id="t4">
      <h2>4. Distributive Conditional Types</h2>
      <div class="meta"><span><strong>Difficulty:</strong> <span class="badge">Intermediate</span></span><span><strong>Prerequisites:</strong> Union types, conditional types, generics</span></div>
      <h3>Overview</h3>
      <p>Distributive conditional types automatically distribute over union types when the checked type is a naked type parameter. This behavior allows you to apply transformations to each member of a union independently. Understanding when distribution occurs (and how to prevent it) is crucial for writing predictable type utilities.</p>
      <h3>Key Concepts</h3>
      <ul>
        <li>Automatic distribution over naked type parameters in unions</li>
        <li>Preventing distribution by wrapping in tuple: [T] extends [U]</li>
        <li>The difference between distributed and non-distributed results</li>
        <li>Extract and Exclude as canonical distributive type examples</li>
        <li>Distribution behavior with never type</li>
      </ul>
      <h3>Code Example</h3>
      <pre><code class="language-typescript">// Distributive (naked type parameter)
type ToArray&lt;T&gt; = T extends any ? T[] : never;
type Distributed = ToArray&lt;string | number&gt;; // string[] | number[]

// Non-distributive (wrapped in tuple)
type ToArrayND&lt;T&gt; = [T] extends [any] ? T[] : never;
type NonDist = ToArrayND&lt;string | number&gt;; // (string | number)[]

// Extract/Exclude patterns
type Extract&lt;T, U&gt; = T extends U ? T : never;
type Exclude&lt;T, U&gt; = T extends U ? never : T;

type Strings = Extract&lt;string | number | boolean, string&gt;; // string
type NoStr = Exclude&lt;string | number | boolean, string&gt;;   // number | boolean

// Check if type is union
type IsUnion&lt;T, U = T&gt; = T extends any ? [U] extends [T] ? false : true : never;
type Test1 = IsUnion&lt;string&gt;;          // false
type Test2 = IsUnion&lt;string | number&gt;; // true</code></pre>
      <div class="resources"><h4>üìö Learning Resources</h4><ul class="res-list">
        <li><a href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types">TypeScript Handbook - Distributive Types</a><span class="desc">Official explanation</span></li>
        <li><a href="https://effectivetypescript.com">Effective TypeScript</a><span class="desc">Item 50 covers distribution in depth</span></li>
      </ul></div>
      <div class="exercises"><h4>üèãÔ∏è Hands-On Exercises</h4><ul>
        <li><a href="https://typehero.dev/challenge/conditional-types">Conditional Types</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/exclude">Exclude</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/extract">Extract</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/nonnullable">NonNullable</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00043-easy-exclude/README.md">Exclude</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00268-easy-if/README.md">If</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00949-medium-anyof/README.md">AnyOf</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
      </ul></div>
    </article>

    <article class="topic" id="t5">
      <h2>5. Tuple Manipulation</h2>
      <div class="meta"><span><strong>Difficulty:</strong> <span class="badge">Intermediate to Advanced</span></span><span><strong>Prerequisites:</strong> Basic tuple types, generics, infer keyword</span></div>
      <h3>Overview</h3>
      <p>Tuple manipulation involves transforming fixed-length array types with heterogeneous element types. TypeScript provides powerful tools including variadic tuple types, labeled elements, and rest elements. These capabilities enable type-safe function composition and are the foundation for type-level arithmetic.</p>
      <h3>Key Concepts</h3>
      <ul>
        <li>Variadic tuple types with spread syntax [...T]</li>
        <li>Extracting first, last, and rest elements using infer</li>
        <li>Concatenating and reversing tuples at the type level</li>
        <li>Named/labeled tuple elements for better IDE support</li>
        <li>Converting between tuples and unions</li>
      </ul>
      <h3>Code Example</h3>
      <pre><code class="language-typescript">// Extract elements
type Head&lt;T extends any[]&gt; = T extends [infer F, ...any[]] ? F : never;
type Tail&lt;T extends any[]&gt; = T extends [any, ...infer R] ? R : [];
type Last&lt;T extends any[]&gt; = T extends [...any[], infer L] ? L : never;

// Concatenate and reverse
type Concat&lt;A extends any[], B extends any[]&gt; = [...A, ...B];
type Reverse&lt;T extends any[]&gt; = T extends [infer F, ...infer R] ? [...Reverse&lt;R&gt;, F] : [];

// Usage
type Nums = [1, 2, 3, 4, 5];
type First = Head&lt;Nums&gt;;           // 1
type Rest = Tail&lt;Nums&gt;;            // [2, 3, 4, 5]
type Combined = Concat&lt;[1, 2], [3, 4]&gt;; // [1, 2, 3, 4]
type Reversed = Reverse&lt;Nums&gt;;     // [5, 4, 3, 2, 1]
type Len = Nums['length'];         // 5

// Tuple to Union
type TupleToUnion&lt;T extends any[]&gt; = T[number];
type Union = TupleToUnion&lt;[1, 2, 3]&gt;; // 1 | 2 | 3</code></pre>
      <div class="resources"><h4>üìö Learning Resources</h4><ul class="res-list">
        <li><a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html">TypeScript 4.0 - Variadic Tuples</a><span class="desc">Feature introduction</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges">Type Challenges</a><span class="desc">Tuple manipulation practice</span></li>
      </ul></div>
      <div class="exercises"><h4>üèãÔ∏è Hands-On Exercises</h4><ul>
        <li><a href="https://typehero.dev/challenge/tuple-length">Tuple Length</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/first-of-array">First of Array</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/last-of-array">Last of Array</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/concat">Concat</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/push">Push</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/unshift">Unshift</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00014-easy-first/README.md">First of Array</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00015-medium-last/README.md">Last of Array</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00016-medium-pop/README.md">Pop</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/03057-easy-push/README.md">Push</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/03192-medium-reverse/README.md">Reverse</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
      </ul></div>
    </article>

    <article class="topic" id="t6">
      <h2>6. Template Literal Types</h2>
      <div class="meta"><span><strong>Difficulty:</strong> <span class="badge">Intermediate</span></span><span><strong>Prerequisites:</strong> String literal types, union types, basic generics</span></div>
      <h3>Overview</h3>
      <p>Template literal types bring string manipulation to the type level, allowing you to create new string literal types through concatenation and pattern matching. Combined with intrinsic types (Uppercase, Lowercase, Capitalize, Uncapitalize), they enable powerful string-based transformations for routes, events, and APIs.</p>
      <h3>Key Concepts</h3>
      <ul>
        <li>Creating string literal types with template syntax</li>
        <li>Intrinsic manipulation: Uppercase, Lowercase, Capitalize, Uncapitalize</li>
        <li>Pattern matching and extracting parts with infer</li>
        <li>Combining with unions for string permutations</li>
        <li>Building type-safe route parsers and event emitters</li>
      </ul>
      <h3>Code Example</h3>
      <pre><code class="language-typescript">type Greeting = `Hello, ${'world'}`; // "Hello, world"

// Union expansion
type Size = 'sm' | 'lg';
type Color = 'red' | 'blue';
type Combo = `${Color}-${Size}`; // "red-sm" | "red-lg" | "blue-sm" | "blue-lg"

// Intrinsic manipulation
type Upper = Uppercase&lt;'hello'&gt;;    // "HELLO"
type Cap = Capitalize&lt;'hello'&gt;;     // "Hello"

// Extract route params
type Params&lt;T&gt; = T extends `${string}:${infer P}/${infer R}` ? P | Params&lt;R&gt;
  : T extends `${string}:${infer P}` ? P : never;
type P = Params&lt;'/users/:id/posts/:pid'&gt;; // "id" | "pid"

// Event handlers
type Handlers&lt;T&gt; = { [K in keyof T as `on${Capitalize&lt;string &amp; K&gt;}`]: (e: T[K]) =&gt; void };
type H = Handlers&lt;{ click: MouseEvent }&gt;; // { onClick: (e: MouseEvent) =&gt; void }

// Split string
type Split&lt;S extends string, D extends string&gt; =
  S extends `${infer H}${D}${infer T}` ? [H, ...Split&lt;T, D&gt;] : [S];
type Parts = Split&lt;'a-b-c', '-'&gt;; // ['a', 'b', 'c']</code></pre>
      <div class="resources"><h4>üìö Learning Resources</h4><ul class="res-list">
        <li><a href="https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html">TypeScript Handbook - Template Literals</a><span class="desc">Official documentation</span></li>
        <li><a href="https://type-level-typescript.com">Type-Level TypeScript</a><span class="desc">String manipulation chapter</span></li>
      </ul></div>
      <div class="exercises"><h4>üèãÔ∏è Hands-On Exercises</h4><ul>
        <li><a href="https://typehero.dev/challenge/template-literal-types">Template Literal Types</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/capitalize">Capitalize</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/trim">Trim</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/replace">Replace</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00106-medium-trimleft/README.md">Trim Left</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00108-medium-trim/README.md">Trim</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00110-medium-capitalize/README.md">Capitalize</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00116-medium-replace/README.md">Replace</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/02070-medium-drop-char/README.md">Drop Char</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00298-medium-length-of-string/README.md">Length of String</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
      </ul></div>
    </article>

    <article class="topic" id="t7">
      <h2>7. Mapped Type Key Remapping</h2>
      <div class="meta"><span><strong>Difficulty:</strong> <span class="badge">Intermediate</span></span><span><strong>Prerequisites:</strong> Mapped types, template literal types, keyof operator</span></div>
      <h3>Overview</h3>
      <p>Key remapping in mapped types (TS 4.1+) allows you to transform the keys of an object type during mapping using the 'as' clause. This enables powerful transformations like prefixing/suffixing keys, filtering keys, and creating entirely new object shapes from existing types.</p>
      <h3>Key Concepts</h3>
      <ul>
        <li>Using 'as' clause in mapped types for key transformation</li>
        <li>Combining with template literal types for string manipulation</li>
        <li>Filtering keys by returning 'never' to exclude them</li>
        <li>Creating getters/setters, prefixed methods, and event handlers</li>
      </ul>
      <h3>Code Example</h3>
      <pre><code class="language-typescript">// Getters
type Getters&lt;T&gt; = { [K in keyof T as `get${Capitalize&lt;string &amp; K&gt;}`]: () =&gt; T[K] };
interface Person { name: string; age: number; }
type PG = Getters&lt;Person&gt;; // { getName: () =&gt; string; getAge: () =&gt; number }

// Filter keys
type OnlyStrings&lt;T&gt; = { [K in keyof T as T[K] extends string ? K : never]: T[K] };

// Remove specific key
type RemoveKind&lt;T&gt; = { [K in keyof T as Exclude&lt;K, 'kind'&gt;]: T[K] };

// Event handlers
type Events&lt;E extends string&gt; = { [K in E as `on${Capitalize&lt;K&gt;}`]: () =&gt; void };
type E = Events&lt;'click' | 'hover'&gt;; // { onClick: () =&gt; void; onHover: () =&gt; void }

// Getters + Setters
type Accessors&lt;T&gt; = {
  [K in keyof T as `get${Capitalize&lt;string &amp; K&gt;}`]: () =&gt; T[K]
} &amp; {
  [K in keyof T as `set${Capitalize&lt;string &amp; K&gt;}`]: (v: T[K]) =&gt; void
};</code></pre>
      <div class="resources"><h4>üìö Learning Resources</h4><ul class="res-list">
        <li><a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#key-remapping-in-mapped-types">TypeScript 4.1 - Key Remapping</a><span class="desc">Feature introduction</span></li>
        <li><a href="https://www.typescriptlang.org/docs/handbook/2/mapped-types.html">TypeScript Handbook - Mapped Types</a><span class="desc">Comprehensive documentation</span></li>
      </ul></div>
      <div class="exercises"><h4>üèãÔ∏è Hands-On Exercises</h4><ul>
        <li><a href="https://typehero.dev/challenge/mapped-types">Mapped Types</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/pick">Pick</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/omit">Omit</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/readonly-2">Readonly 2</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00003-medium-omit/README.md">Omit</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00008-medium-readonly-2/README.md">Readonly 2</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00009-medium-deep-readonly/README.md">Deep Readonly</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/01367-medium-remove-index-signature/README.md">Remove Index Signature</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
      </ul></div>
    </article>

    <article class="topic" id="t8">
      <h2>8. Recursive Conditional Types</h2>
      <div class="meta"><span><strong>Difficulty:</strong> <span class="badge advanced">Advanced</span></span><span><strong>Prerequisites:</strong> Conditional types, generics, infer keyword, tuples</span></div>
      <h3>Overview</h3>
      <p>Recursive conditional types allow you to define types that reference themselves, enabling complex type transformations that operate on nested structures of arbitrary depth. This technique is essential for working with deeply nested objects, tree structures, and implementing utility types like DeepPartial and DeepReadonly.</p>
      <h3>Key Concepts</h3>
      <ul>
        <li>Self-referential type definitions</li>
        <li>Base cases to terminate recursion</li>
        <li>TypeScript's recursion depth limits (~50 levels)</li>
        <li>Tail-call optimization patterns</li>
        <li>Common patterns: DeepPartial, DeepReadonly, Flatten, Awaited</li>
      </ul>
      <h3>Code Example</h3>
      <pre><code class="language-typescript">// Deep Partial - makes all nested properties optional
type DeepPartial&lt;T&gt; = T extends object ? { [P in keyof T]?: DeepPartial&lt;T[P]&gt; } : T;

// Flatten nested arrays
type Flatten&lt;T&gt; = T extends Array&lt;infer U&gt; ? Flatten&lt;U&gt; : T;

// Unwrap nested Promises
type Awaited&lt;T&gt; = T extends Promise&lt;infer U&gt; ? Awaited&lt;U&gt; : T;

// Usage
type Nested = { a: { b: { c: string } } };
type DP = DeepPartial&lt;Nested&gt;; // { a?: { b?: { c?: string } } }
type Flat = Flatten&lt;number[][][][]&gt;; // number
type Res = Awaited&lt;Promise&lt;Promise&lt;string&gt;&gt;&gt;; // string

// Deep Readonly
type DeepReadonly&lt;T&gt; = T extends object
  ? { readonly [P in keyof T]: DeepReadonly&lt;T[P]&gt; } : T;

// Collect all paths
type Paths&lt;T, P extends string = ''&gt; = T extends object
  ? { [K in keyof T &amp; string]: `${P}${K}` | Paths&lt;T[K], `${P}${K}.`&gt; }[keyof T &amp; string]
  : never;</code></pre>
      <div class="resources"><h4>üìö Learning Resources</h4><ul class="res-list">
        <li><a href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html">TypeScript Handbook - Conditional Types</a><span class="desc">Official documentation</span></li>
        <li><a href="https://type-level-typescript.com">Type-Level TypeScript</a><span class="desc">Recursive types chapter</span></li>
      </ul></div>
      <div class="exercises"><h4>üèãÔ∏è Hands-On Exercises</h4><ul>
        <li><a href="https://typehero.dev/challenge/deep-readonly">Deep Readonly</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/flatten">Flatten</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/flatten-depth">Flatten Depth</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00009-medium-deep-readonly/README.md">Deep Readonly</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00459-medium-flatten/README.md">Flatten</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/03243-medium-flattendepth/README.md">Flatten Depth</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00213-hard-vue-basic-props/README.md">Vue Basic Props</a><span class="ex-diff ex-hard">Hard</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00956-hard-deeppick/README.md">DeepPick</a><span class="ex-diff ex-hard">Hard</span><span class="ex-src">Type Challenges</span></li>
      </ul></div>
    </article>

    <article class="topic" id="t9">
      <h2>9. Variance and Contravariance</h2>
      <div class="meta"><span><strong>Difficulty:</strong> <span class="badge advanced">Advanced</span></span><span><strong>Prerequisites:</strong> Generics, type compatibility, function types, inheritance</span></div>
      <h3>Overview</h3>
      <p>Variance describes how subtyping relationships between complex types relate to subtyping between their components. Understanding covariance, contravariance, and invariance is essential for designing type-safe generic APIs and understanding why union-to-intersection conversion works.</p>
      <h3>Key Concepts</h3>
      <ul>
        <li>Covariance: subtype relationship preserved (output positions like return types)</li>
        <li>Contravariance: subtype relationship reversed (input positions like parameters)</li>
        <li>Invariance: no subtype relationship (both in and out positions)</li>
        <li>Using 'in' and 'out' modifiers for explicit variance annotation (TS 4.7+)</li>
        <li>Why function parameters are contravariant and return types are covariant</li>
      </ul>
      <h3>Code Example</h3>
      <pre><code class="language-typescript">interface Producer&lt;out T&gt; { produce(): T; }  // Covariant
interface Consumer&lt;in T&gt; { consume(x: T): void; }  // Contravariant
interface Box&lt;T&gt; { get(): T; set(x: T): void; }  // Invariant

class Animal { name = ''; }
class Dog extends Animal { bark() {} }

// Covariant - preserved
const dogs: Dog[] = [new Dog()];
const animals: readonly Animal[] = dogs; // OK

// Contravariant - reversed
type Handler&lt;T&gt; = (x: T) =&gt; void;
const animalH: Handler&lt;Animal&gt; = (a) =&gt; console.log(a.name);
const dogH: Handler&lt;Dog&gt; = animalH; // OK - contravariant!

// This is why union-to-intersection works:
// Contravariant position collects into intersection
// (A =&gt; void) | (B =&gt; void) in param position becomes A &amp; B</code></pre>
      <div class="resources"><h4>üìö Learning Resources</h4><ul class="res-list">
        <li><a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#optional-variance-annotations-for-type-parameters">TypeScript 4.7 - Variance Annotations</a><span class="desc">in/out modifiers</span></li>
        <li><a href="https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance">Stephan Boyer's Article</a><span class="desc">Excellent explanation</span></li>
      </ul></div>
      <div class="exercises"><h4>üèãÔ∏è Hands-On Exercises</h4><ul>
        <li><a href="https://typehero.dev/challenge/covariance-and-contravariance">Covariance and Contravariance</a><span class="ex-diff ex-hard">Hard</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00007-easy-readonly/README.md">Readonly (covariance)</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://www.totaltypescript.com/workshops/type-transformations/conditional-types-and-infer/infer-with-generics">Infer with Generics (variance demo)</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Total TypeScript</span></li>
        <li><a href="https://www.typescriptlang.org/play?#code/PTAEBUAsFMCdtAQ3qALgdwPYFN5gIwCsAzRAJ2gBNIBjUAM2kIAdFaB+YVAby1AF5QAIgBGzCgEYA3EQC+RImQqotASz5IALI14ChYgDSTp0ACbNFVADb9sNcAE8ADgChjJsxfCVBF0IA">Playground: Variance Demo</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">TS Playground</span></li>
      </ul></div>
    </article>

    <article class="topic" id="t10">
      <h2>10. Union to Intersection Conversion</h2>
      <div class="meta"><span><strong>Difficulty:</strong> <span class="badge advanced">Advanced</span></span><span><strong>Prerequisites:</strong> Distributive conditional types, function contravariance, infer keyword</span></div>
      <h3>Overview</h3>
      <p>Converting a union type to an intersection type exploits function parameter contravariance to "flip" a union into an intersection. This pattern is essential for merging object types from unions and building complex type utilities.</p>
      <h3>Key Concepts</h3>
      <ul>
        <li>Exploiting contravariance in function parameters</li>
        <li>Why (A‚áívoid)|(B‚áívoid) becomes (A&amp;B)‚áívoid in parameter position</li>
        <li>Distribute first, then collect via contravariance</li>
        <li>LastInUnion and UnionToTuple patterns</li>
      </ul>
      <h3>Code Example</h3>
      <pre><code class="language-typescript">// The classic trick
type UnionToIntersection&lt;U&gt; = 
  (U extends any ? (x: U) =&gt; void : never) extends (x: infer I) =&gt; void ? I : never;

type U = { a: 1 } | { b: 2 };
type I = UnionToIntersection&lt;U&gt;; // { a: 1 } &amp; { b: 2 }

// LastInUnion
type Last&lt;U&gt; = UnionToIntersection&lt;
  U extends any ? (x: U) =&gt; void : never
&gt; extends (x: infer L) =&gt; void ? L : never;
type L = Last&lt;'a' | 'b' | 'c'&gt;; // 'c'

// UnionToTuple
type UTT&lt;U, L = Last&lt;U&gt;&gt; = [U] extends [never] ? [] : [...UTT&lt;Exclude&lt;U, L&gt;&gt;, L];
type T = UTT&lt;'a' | 'b'&gt;; // ['a', 'b']

// Merge union of objects
type Merge&lt;U&gt; = { [K in keyof UnionToIntersection&lt;U&gt;]: UnionToIntersection&lt;U&gt;[K] };
type M = Merge&lt;{ a: 1 } | { b: 2 }&gt;; // { a: 1; b: 2 }</code></pre>
      <div class="resources"><h4>üìö Learning Resources</h4><ul class="res-list">
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00055-hard-union-to-intersection/README.md">Type Challenges - Union to Intersection</a><span class="desc">The canonical challenge</span></li>
        <li><a href="https://stackoverflow.com/questions/50374908/transform-union-type-to-intersection-type">Stack Overflow Explanation</a><span class="desc">Original detailed breakdown</span></li>
      </ul></div>
      <div class="exercises"><h4>üèãÔ∏è Hands-On Exercises</h4><ul>
        <li><a href="https://typehero.dev/challenge/union-to-intersection">Union to Intersection</a><span class="ex-diff ex-hard">Hard</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00055-hard-union-to-intersection/README.md">Union to Intersection</a><span class="ex-diff ex-hard">Hard</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00730-hard-union-to-tuple/README.md">Union to Tuple</a><span class="ex-diff ex-hard">Hard</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00010-medium-tuple-to-union/README.md">Tuple to Union</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00599-medium-merge/README.md">Merge</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
      </ul></div>
    </article>

    <article class="topic" id="t11">
      <h2>11. Declaration Merging</h2>
      <div class="meta"><span><strong>Difficulty:</strong> <span class="badge">Intermediate</span></span><span><strong>Prerequisites:</strong> Interfaces, namespaces, modules, declaration files</span></div>
      <h3>Overview</h3>
      <p>Declaration merging combines multiple declarations with the same name into a single definition. This enables extending existing types, augmenting third-party libraries, and is foundational for HKT simulation patterns.</p>
      <h3>Key Concepts</h3>
      <ul>
        <li>Interface merging: properties combined</li>
        <li>Namespace merging: exports combined</li>
        <li>Module augmentation for extending third-party types</li>
        <li>Global augmentation</li>
        <li>Namespace + class/enum merging</li>
      </ul>
      <h3>Code Example</h3>
      <pre><code class="language-typescript">// Interface merging
interface User { name: string; }
interface User { age: number; }
// Merged: { name: string; age: number }

// Module augmentation
declare module 'express' {
  interface Request { user?: { id: string; role: string } }
}

// Namespace + class merging
class Album { label: Album.Label; constructor(l: Album.Label) { this.label = l; } }
namespace Album {
  export interface Label { name: string }
  export function create(l: Label) { return new Album(l); }
}

// Global augmentation
declare global {
  interface Array&lt;T&gt; { first(): T | undefined }
}

// Enum + namespace merging
enum Color { Red, Green, Blue }
namespace Color {
  export function parse(s: string): Color | undefined {
    return Color[s as keyof typeof Color];
  }
}</code></pre>
      <div class="resources"><h4>üìö Learning Resources</h4><ul class="res-list">
        <li><a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html">TypeScript Handbook - Declaration Merging</a><span class="desc">Official documentation</span></li>
        <li><a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a><span class="desc">Real-world examples</span></li>
      </ul></div>
      <div class="exercises"><h4>üèãÔ∏è Hands-On Exercises</h4><ul>
        <li><a href="https://typehero.dev/challenge/declare-global">Declare Global</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/module-augmentation">Module Augmentation</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://www.totaltypescript.com/workshops/type-transformations/modules-and-declaration-merging">Modules and Declaration Merging</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Total TypeScript</span></li>
        <li><a href="https://www.typescriptlang.org/play?#code/CYUwxgNghgTiAEAzArgOzAFwJYHtVJxwB4AVeAZwIF4BeAKHnhACIAJAVQBkBRAbTYA0PAIwAuWgF0A3EA">Playground: Interface Merging</a><span class="ex-diff ex-easy">Easy</span><span class="ex-src">TS Playground</span></li>
      </ul></div>
    </article>

    <article class="topic" id="t12">
      <h2>12. Advanced Module and Namespace Patterns</h2>
      <div class="meta"><span><strong>Difficulty:</strong> <span class="badge">Upper Intermediate</span></span><span><strong>Prerequisites:</strong> ES modules, declaration files, declaration merging</span></div>
      <h3>Overview</h3>
      <p>Advanced module patterns include ambient modules, wildcard declarations, path mapping, and sophisticated declaration file authoring. Essential for library authors and complex build systems.</p>
      <h3>Key Concepts</h3>
      <ul>
        <li>Ambient module declarations for untyped packages</li>
        <li>Wildcard module patterns for CSS/images</li>
        <li>Path mapping in tsconfig</li>
        <li>Package.json exports and types</li>
        <li>Namespaces for organizing types</li>
      </ul>
      <h3>Code Example</h3>
      <pre><code class="language-typescript">// Ambient modules
declare module 'untyped-lib' {
  export function doSomething(x: string): number;
}

// Wildcard modules
declare module '*.css' { const c: { [k: string]: string }; export default c; }
declare module '*.png' { const s: string; export default s; }

// Path mapping (tsconfig.json)
// "paths": { "@components/*": ["src/components/*"] }
import { Button } from '@components/Button';

// Namespace for grouping
export namespace API {
  export interface User { id: string; name: string }
  export namespace Requests {
    export interface Create { name: string; email: string }
  }
}
const u: API.User = { id: '1', name: 'Alice' };</code></pre>
      <div class="resources"><h4>üìö Learning Resources</h4><ul class="res-list">
        <li><a href="https://www.typescriptlang.org/docs/handbook/modules.html">TypeScript Handbook - Modules</a><span class="desc">Official documentation</span></li>
        <li><a href="https://arethetypeswrong.github.io/">Are The Types Wrong?</a><span class="desc">Check package exports</span></li>
      </ul></div>
      <div class="exercises"><h4>üèãÔ∏è Hands-On Exercises</h4><ul>
        <li><a href="https://typehero.dev/challenge/module-augmentation">Module Augmentation</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/namespace">Namespace</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://www.totaltypescript.com/how-to-create-an-npm-package">Create an NPM Package</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Total TypeScript</span></li>
        <li><a href="https://github.com/arethetypeswrong/arethetypeswrong.github.io">Analyze Your Package Types</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">ATTW Tool</span></li>
      </ul></div>
    </article>

    <article class="topic" id="t13">
      <h2>13. Branded Types (Nominal Typing)</h2>
      <div class="meta"><span><strong>Difficulty:</strong> <span class="badge">Intermediate</span></span><span><strong>Prerequisites:</strong> Type assertions, type guards, intersection types</span></div>
      <h3>Overview</h3>
      <p>Branded types create nominally distinct types that are structurally identical but not assignable to each other. This prevents bugs like passing a UserId where a PostId is expected, and enables compile-time validation guarantees.</p>
      <h3>Key Concepts</h3>
      <ul>
        <li>Creating brand symbols using unique symbol</li>
        <li>Distinguishing structurally identical types (UserId vs PostId)</li>
        <li>Validation functions returning branded types</li>
        <li>Integration with validation libraries like zod</li>
      </ul>
      <h3>Code Example</h3>
      <pre><code class="language-typescript">declare const brand: unique symbol;
type Brand&lt;T, B&gt; = T &amp; { [brand]: B };

// Distinct ID types
type UserId = Brand&lt;string, 'UserId'&gt;;
type PostId = Brand&lt;string, 'PostId'&gt;;

function getUser(id: UserId) {}
function getPost(id: PostId) {}

const uid = 'u1' as UserId;
const pid = 'p1' as PostId;

getUser(uid); // OK
getUser(pid); // Error!

// Validated types
type Email = Brand&lt;string, 'Email'&gt;;
function validateEmail(s: string): Email | null {
  return s.includes('@') ? s as Email : null;
}

function sendEmail(to: Email, subject: string) {}

const email = validateEmail('<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4135243235012439202c312d246f222e2c">[email&#160;protected]</a>');
if (email) sendEmail(email, 'Hello'); // Type-safe!</code></pre>
      <div class="resources"><h4>üìö Learning Resources</h4><ul class="res-list">
        <li><a href="https://type-level-typescript.com">Type-Level TypeScript - Branded Types</a><span class="desc">Nominal typing patterns</span></li>
        <li><a href="https://zod.dev">Zod</a><span class="desc">Validation with brands built-in</span></li>
      </ul></div>
      <div class="exercises"><h4>üèãÔ∏è Hands-On Exercises</h4><ul>
        <li><a href="https://typehero.dev/challenge/opaque-types">Opaque Types (Branded)</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/nominal-typing">Nominal Typing</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00062-medium-type-lookup/README.md">Type Lookup</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://www.totaltypescript.com/workshops/type-transformations/branded-types">Branded Types Workshop</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Total TypeScript</span></li>
        <li><a href="https://zod.dev/?id=brand">Zod Brand Practice</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Zod Docs</span></li>
      </ul></div>
    </article>

    <article class="topic" id="t14">
      <h2>14. Type-Safe Builder Pattern</h2>
      <div class="meta"><span><strong>Difficulty:</strong> <span class="badge advanced">Advanced</span></span><span><strong>Prerequisites:</strong> Generics, mapped types, conditional types, method chaining</span></div>
      <h3>Overview</h3>
      <p>The type-safe builder pattern uses TypeScript's type system to enforce that all required fields are set before building, prevent setting the same field twice, and provide accurate autocompletion at each step.</p>
      <h3>Key Concepts</h3>
      <ul>
        <li>Tracking set/unset fields in the type parameter</li>
        <li>Progressive type narrowing as methods are called</li>
        <li>build() only available when all required fields are set</li>
        <li>Preventing duplicate field setting</li>
      </ul>
      <h3>Code Example</h3>
      <pre><code class="language-typescript">interface Config { name: string; email: string; age?: number }

type Required&lt;T&gt; = { [K in keyof T]-?: undefined extends T[K] ? never : K }[keyof T];

type Builder&lt;T, Set extends keyof T = never&gt; = {
  [K in keyof T as K extends Set ? never : `set${Capitalize&lt;string &amp; K&gt;}`]: 
    (v: T[K]) =&gt; Builder&lt;T, Set | K&gt;
} &amp; (Required&lt;T&gt; extends Set ? { build(): T } : {});

function createBuilder(): Builder&lt;Config&gt; {
  const c: Partial&lt;Config&gt; = {};
  const b: any = {
    setName: (n: string) =&gt; { c.name = n; return b; },
    setEmail: (e: string) =&gt; { c.email = e; return b; },
    setAge: (a: number) =&gt; { c.age = a; return b; },
    build: () =&gt; c as Config
  };
  return b;
}

createBuilder().setName('A').setEmail('a@b').build(); // OK
// createBuilder().setName('A').build(); // Error - email required!</code></pre>
      <div class="resources"><h4>üìö Learning Resources</h4><ul class="res-list">
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00012-medium-chainable-options/README.md">Type Challenges - Chainable</a><span class="desc">Builder pattern challenge</span></li>
        <li><a href="https://kysely.dev">Kysely</a><span class="desc">Type-safe SQL query builder</span></li>
      </ul></div>
      <div class="exercises"><h4>üèãÔ∏è Hands-On Exercises</h4><ul>
        <li><a href="https://typehero.dev/challenge/chainable-options">Chainable Options</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00012-medium-chainable-options/README.md">Chainable Options</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00006-hard-simple-vue/README.md">Simple Vue</a><span class="ex-diff ex-hard">Hard</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00213-hard-vue-basic-props/README.md">Vue Basic Props</a><span class="ex-diff ex-hard">Hard</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://kysely.dev/docs/getting-started">Build a Query with Kysely</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Kysely</span></li>
      </ul></div>
    </article>

    <article class="topic" id="t15">
      <h2>15. Deep Path Types and Dot Notation Access</h2>
      <div class="meta"><span><strong>Difficulty:</strong> <span class="badge advanced">Advanced</span></span><span><strong>Prerequisites:</strong> Template literal types, recursive types, mapped types, conditional types</span></div>
      <h3>Overview</h3>
      <p>Deep path types allow you to express paths into nested objects using dot notation strings (like "user.address.city") and retrieve the types at those paths. This pattern powers type-safe form libraries, ORM query builders, and lodash's get/set functions.</p>
      <h3>Key Concepts</h3>
      <ul>
        <li>Generating all valid path strings for a nested object type</li>
        <li>Extracting the type at a given path</li>
        <li>Handling arrays, optional properties, and nullable types</li>
        <li>Type-safe get/set functions</li>
      </ul>
      <h3>Code Example</h3>
      <pre><code class="language-typescript">// Get all paths
type Paths&lt;T, P extends string = ''&gt; = T extends object
  ? { [K in keyof T &amp; string]: `${P}${K}` | Paths&lt;T[K], `${P}${K}.`&gt; }[keyof T &amp; string]
  : never;

// Get type at path
type PathValue&lt;T, P&gt; = P extends `${infer K}.${infer R}`
  ? K extends keyof T ? PathValue&lt;T[K], R&gt; : never
  : P extends keyof T ? T[P] : never;

interface User { name: string; addr: { city: string; geo: { lat: number } } }

type UP = Paths&lt;User&gt;; // "name" | "addr" | "addr.city" | "addr.geo" | "addr.geo.lat"
type City = PathValue&lt;User, 'addr.city'&gt;; // string
type Lat = PathValue&lt;User, 'addr.geo.lat'&gt;; // number

// Type-safe get
function get&lt;T, P extends Paths&lt;T&gt;&gt;(o: T, p: P): PathValue&lt;T, P&gt; {
  return p.split('.').reduce((x: any, k) =&gt; x?.[k], o);
}

const user: User = { name: 'A', addr: { city: 'NYC', geo: { lat: 40 } } };
const city = get(user, 'addr.city');    // string
const lat = get(user, 'addr.geo.lat');  // number</code></pre>
      <div class="resources"><h4>üìö Learning Resources</h4><ul class="res-list">
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/07258-hard-object-key-paths/README.md">Type Challenges - Object Key Paths</a><span class="desc">Path generation challenge</span></li>
        <li><a href="https://react-hook-form.com">React Hook Form</a><span class="desc">Real-world path types</span></li>
      </ul></div>
      <div class="exercises"><h4>üèãÔ∏è Hands-On Exercises</h4><ul>
        <li><a href="https://typehero.dev/challenge/get">Get (lodash-style)</a><span class="ex-diff ex-hard">Hard</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/object-key-paths">Object Key Paths</a><span class="ex-diff ex-hard">Hard</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00270-hard-typed-get/README.md">Typed Get</a><span class="ex-diff ex-hard">Hard</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/07258-hard-object-key-paths/README.md">Object Key Paths</a><span class="ex-diff ex-hard">Hard</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/01130-medium-replacekeys/README.md">Replace Keys</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/02757-medium-partialbykeys/README.md">Partial By Keys</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
      </ul></div>
    </article>

    <article class="topic" id="t16">
      <h2>16. Type-Safe State Machines</h2>
      <div class="meta"><span><strong>Difficulty:</strong> <span class="badge advanced">Advanced</span></span><span><strong>Prerequisites:</strong> Discriminated unions, mapped types, conditional types, generics</span></div>
      <h3>Overview</h3>
      <p>Type-safe state machines use TypeScript's type system to enforce valid state transitions at compile time. Only valid events for the current state are allowed, and the resulting state type is correctly inferred.</p>
      <h3>Key Concepts</h3>
      <ul>
        <li>Defining states as discriminated unions</li>
        <li>Mapping valid events/transitions for each state</li>
        <li>Restricting event handlers to valid events for current state</li>
        <li>Inferring the next state type from transitions</li>
      </ul>
      <h3>Code Example</h3>
      <pre><code class="language-typescript">type State = 
  | { s: 'idle' }
  | { s: 'loading'; t: number }
  | { s: 'done'; data: string };

type Event =
  | { e: 'FETCH' }
  | { e: 'DONE'; data: string }
  | { e: 'RESET' };

type Valid = { idle: 'FETCH'; loading: 'DONE'; done: 'RESET' | 'FETCH' };

type Allowed&lt;S extends State&gt; = Extract&lt;Event, { e: Valid[S['s']] }&gt;;

function transition&lt;S extends State&gt;(state: S, event: Allowed&lt;S&gt;): State {
  switch (state.s) {
    case 'idle': return { s: 'loading', t: Date.now() };
    case 'loading': return { s: 'done', data: (event as any).data };
    case 'done': return event.e === 'RESET' ? { s: 'idle' } : { s: 'loading', t: Date.now() };
  }
}

const idle: State = { s: 'idle' };
transition(idle, { e: 'FETCH' }); // OK
// transition(idle, { e: 'DONE', data: '' }); // Error!</code></pre>
      <div class="resources"><h4>üìö Learning Resources</h4><ul class="res-list">
        <li><a href="https://xstate.js.org">XState</a><span class="desc">Production state machine library</span></li>
        <li><a href="https://stately.ai/docs/typescript">XState TypeScript Guide</a><span class="desc">Typing state machines</span></li>
      </ul></div>
      <div class="exercises"><h4>üèãÔ∏è Hands-On Exercises</h4><ul>
        <li><a href="https://typehero.dev/challenge/finite-state-machine">Finite State Machine</a><span class="ex-diff ex-hard">Hard</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00006-hard-simple-vue/README.md">Simple Vue (state patterns)</a><span class="ex-diff ex-hard">Hard</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://stately.ai/docs/xstate-v5/migration">XState v5 Migration</a><span class="ex-diff ex-hard">Hard</span><span class="ex-src">XState</span></li>
        <li><a href="https://stately.ai/editor">Stately Editor</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Stately</span> - Visual state machine builder</li>
      </ul></div>
    </article>

    <article class="topic" id="t17">
      <h2>17. Type-Level Arithmetic</h2>
      <div class="meta"><span><strong>Difficulty:</strong> <span class="badge expert">Expert</span></span><span><strong>Prerequisites:</strong> Recursive types, tuple manipulation, conditional types, infer</span></div>
      <h3>Overview</h3>
      <p>Type-level arithmetic involves performing mathematical operations like addition, subtraction, and comparison entirely within TypeScript's type system using tuple lengths. This enables compile-time validations and range types.</p>
      <h3>Key Concepts</h3>
      <ul>
        <li>Representing numbers as tuple lengths</li>
        <li>Addition via tuple concatenation</li>
        <li>Subtraction via tuple destructuring</li>
        <li>Comparison operations at type level</li>
        <li>Range and vector types</li>
      </ul>
      <h3>Code Example</h3>
      <pre><code class="language-typescript">type BuildTuple&lt;N, T extends any[] = []&gt; = T['length'] extends N ? T : BuildTuple&lt;N, [...T, 0]&gt;;

// Add
type Add&lt;A extends number, B extends number&gt; = [...BuildTuple&lt;A&gt;, ...BuildTuple&lt;B&gt;]['length'];
type Sum = Add&lt;3, 4&gt;;  // 7

// Subtract
type Sub&lt;A extends number, B extends number&gt; = 
  BuildTuple&lt;A&gt; extends [...BuildTuple&lt;B&gt;, ...infer R] ? R['length'] : never;
type Diff = Sub&lt;10, 3&gt;; // 7

// Less than
type LT&lt;A extends number, B extends number&gt; =
  BuildTuple&lt;A&gt; extends [...BuildTuple&lt;B&gt;, ...any[]] ? false : true;
type Less = LT&lt;3, 5&gt;;   // true

// Range (0 to N-1)
type Range&lt;N, A extends number[] = []&gt; = A['length'] extends N ? A[number] : Range&lt;N, [...A, A['length']]&gt;;
type R5 = Range&lt;5&gt;; // 0 | 1 | 2 | 3 | 4

// Fixed-length vector
type Vec&lt;N extends number&gt; = BuildTuple&lt;N, number[]&gt; &amp; number[];
type Vec3 = Vec&lt;3&gt;; // [number, number, number]
const v: Vec3 = [1, 2, 3]; // OK</code></pre>
      <div class="resources"><h4>üìö Learning Resources</h4><ul class="res-list">
        <li><a href="https://github.com/type-challenges/type-challenges">Type Challenges</a><span class="desc">Arithmetic challenges</span></li>
        <li><a href="https://github.com/gvergnaud/hotscript">HotScript</a><span class="desc">Type-level ops library</span></li>
      </ul></div>
      <div class="exercises"><h4>üèãÔ∏è Hands-On Exercises</h4><ul>
        <li><a href="https://typehero.dev/challenge/integer-to-positive">Integer to Positive</a><span class="ex-diff ex-hard">Hard</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/absolute">Absolute</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/percentage-parser">Percentage Parser</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/04425-medium-greater-than/README.md">Greater Than</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/02257-medium-minusone/README.md">MinusOne</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00529-medium-absolute/README.md">Absolute</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/08804-hard-two-sum/README.md">Two Sum</a><span class="ex-diff ex-hard">Hard</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00476-extreme-sum/README.md">Sum (Extreme)</a><span class="ex-diff ex-extreme">Extreme</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00517-extreme-multiply/README.md">Multiply (Extreme)</a><span class="ex-diff ex-extreme">Extreme</span><span class="ex-src">Type Challenges</span></li>
      </ul></div>
    </article>

    <article class="topic" id="t18">
      <h2>18. Currying and Function Composition Types</h2>
      <div class="meta"><span><strong>Difficulty:</strong> <span class="badge expert">Expert</span></span><span><strong>Prerequisites:</strong> Tuple manipulation, recursive types, variadic tuples, function types</span></div>
      <h3>Overview</h3>
      <p>Typing curried functions and function composition at the type level requires sophisticated manipulation of function signatures and parameter tuples. These patterns are essential for functional programming libraries like fp-ts and Ramda.</p>
      <h3>Key Concepts</h3>
      <ul>
        <li>Converting (a,b,c)‚áíd to (a)‚áí(b)‚áí(c)‚áíd</li>
        <li>Type-safe pipe and compose</li>
        <li>Partial application types</li>
        <li>Return type inference through function chains</li>
      </ul>
      <h3>Code Example</h3>
      <pre><code class="language-typescript">// Curry type
type Curry&lt;F&gt; = F extends (...args: infer A) =&gt; infer R
  ? A extends [infer F, ...infer Rest]
    ? Rest extends [] ? (a: F) =&gt; R : (a: F) =&gt; Curry&lt;(...args: Rest) =&gt; R&gt;
    : R
  : never;

type Orig = (a: string, b: number, c: boolean) =&gt; void;
type C = Curry&lt;Orig&gt;; // (a: string) =&gt; (a: number) =&gt; (a: boolean) =&gt; void

// Partial application
type Partial&lt;F, A extends any[]&gt; = F extends (...args: [...A, ...infer R]) =&gt; infer Ret
  ? (...args: R) =&gt; Ret : never;
type P1 = Partial&lt;Orig, [string]&gt;; // (b: number, c: boolean) =&gt; void

// Pipe type
declare function pipe&lt;A, B&gt;(f: (a: A) =&gt; B): (a: A) =&gt; B;
declare function pipe&lt;A, B, C&gt;(f: (a: A) =&gt; B, g: (b: B) =&gt; C): (a: A) =&gt; C;
declare function pipe&lt;A, B, C, D&gt;(f: (a: A) =&gt; B, g: (b: B) =&gt; C, h: (c: C) =&gt; D): (a: A) =&gt; D;

const process = pipe(
  (x: string) =&gt; x.length,
  (x: number) =&gt; x * 2,
  (x: number) =&gt; x.toString()
); // (a: string) =&gt; string</code></pre>
      <div class="resources"><h4>üìö Learning Resources</h4><ul class="res-list">
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00017-hard-currying-1/README.md">Type Challenges - Currying</a><span class="desc">Currying challenge</span></li>
        <li><a href="https://gcanti.github.io/fp-ts/modules/function.ts.html">fp-ts Function Module</a><span class="desc">Production implementations</span></li>
      </ul></div>
      <div class="exercises"><h4>üèãÔ∏è Hands-On Exercises</h4><ul>
        <li><a href="https://typehero.dev/challenge/currying-1">Currying 1</a><span class="ex-diff ex-hard">Hard</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://typehero.dev/challenge/currying-2">Currying 2</a><span class="ex-diff ex-extreme">Extreme</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00017-hard-currying-1/README.md">Currying 1</a><span class="ex-diff ex-hard">Hard</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00462-extreme-currying-2/README.md">Currying 2 (with placeholders)</a><span class="ex-diff ex-extreme">Extreme</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/02059-hard-drop-string/README.md">Drop String</a><span class="ex-diff ex-hard">Hard</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00151-extreme-query-string-parser/README.md">Query String Parser</a><span class="ex-diff ex-extreme">Extreme</span><span class="ex-src">Type Challenges</span></li>
      </ul></div>
    </article>

    <article class="topic" id="t19">
      <h2>19. Higher-Kinded Type (HKT) Simulation</h2>
      <div class="meta"><span><strong>Difficulty:</strong> <span class="badge expert">Expert</span></span><span><strong>Prerequisites:</strong> Advanced generics, declaration merging, functional programming concepts</span></div>
      <h3>Overview</h3>
      <p>Higher-kinded types are type constructors (like Array without a type argument). TypeScript doesn't natively support HKTs, but simulation patterns enable Functor, Monad, and other FP abstractions through URI-based encoding and declaration merging.</p>
      <h3>Key Concepts</h3>
      <ul>
        <li>Type constructors vs concrete types</li>
        <li>URI-based HKT simulation (fp-ts approach)</li>
        <li>Defunctionalization via interface merging</li>
        <li>Implementing Functor, Monad generically</li>
      </ul>
      <h3>Code Example</h3>
      <pre><code class="language-typescript">// URI to Kind mapping
interface URItoKind&lt;A&gt; {
  Array: Array&lt;A&gt;;
  Option: Option&lt;A&gt;;
}

type URIS = keyof URItoKind&lt;any&gt;;
type Kind&lt;URI extends URIS, A&gt; = URItoKind&lt;A&gt;[URI];

// Option type
type Option&lt;A&gt; = { _tag: 'Some'; value: A } | { _tag: 'None' };
const some = &lt;A&gt;(a: A): Option&lt;A&gt; =&gt; ({ _tag: 'Some', value: a });
const none: Option&lt;never&gt; = { _tag: 'None' };

// Functor interface
interface Functor&lt;F extends URIS&gt; {
  map: &lt;A, B&gt;(fa: Kind&lt;F, A&gt;, f: (a: A) =&gt; B) =&gt; Kind&lt;F, B&gt;;
}

// Implementations
const arrayF: Functor&lt;'Array'&gt; = { map: (fa, f) =&gt; fa.map(f) };
const optionF: Functor&lt;'Option'&gt; = { 
  map: (fa, f) =&gt; fa._tag === 'None' ? none : some(f(fa.value)) 
};

// Generic over any Functor
function double&lt;F extends URIS&gt;(F: Functor&lt;F&gt;, fa: Kind&lt;F, number&gt;): Kind&lt;F, number&gt; {
  return F.map(fa, n =&gt; n * 2);
}

double(arrayF, [1, 2, 3]);  // [2, 4, 6]
double(optionF, some(5));   // Some(10)</code></pre>
      <div class="resources"><h4>üìö Learning Resources</h4><ul class="res-list">
        <li><a href="https://gcanti.github.io/fp-ts/">fp-ts</a><span class="desc">Production HKT implementation</span></li>
        <li><a href="https://effect.website">Effect-TS</a><span class="desc">Modern HKT patterns</span></li>
      </ul></div>
      <div class="exercises"><h4>üèãÔ∏è Hands-On Exercises</h4><ul>
        <li><a href="https://typehero.dev/challenge/higher-kinded-types">Higher-Kinded Types</a><span class="ex-diff ex-extreme">Extreme</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://github.com/gcanti/fp-ts/blob/master/tutorials/getting-started/create-functor-instance.md">Create Functor Instance (fp-ts)</a><span class="ex-diff ex-hard">Hard</span><span class="ex-src">fp-ts</span></li>
        <li><a href="https://github.com/gcanti/fp-ts/blob/master/tutorials/getting-started/create-monad-instance.md">Create Monad Instance (fp-ts)</a><span class="ex-diff ex-extreme">Extreme</span><span class="ex-src">fp-ts</span></li>
        <li><a href="https://effect.website/docs/getting-started/introduction">Effect Getting Started</a><span class="ex-diff ex-hard">Hard</span><span class="ex-src">Effect</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00006-hard-simple-vue/README.md">Simple Vue (HKT patterns)</a><span class="ex-diff ex-hard">Hard</span><span class="ex-src">Type Challenges</span></li>
      </ul></div>
    </article>

    <article class="topic" id="t20">
      <h2>20. Type-Level JSON Parsing</h2>
      <div class="meta"><span><strong>Difficulty:</strong> <span class="badge expert">Expert</span></span><span><strong>Prerequisites:</strong> All previous topics ‚Äî this is the capstone</span></div>
      <h3>Overview</h3>
      <p>Type-level JSON parsing is the ultimate test of TypeScript's type system. It involves parsing JSON string literals into TypeScript types at compile time. While primarily academic, it demonstrates mastery of all advanced type features.</p>
      <h3>Key Concepts</h3>
      <ul>
        <li>Type-level tokenization</li>
        <li>Recursive descent parsing patterns</li>
        <li>Handling nested structures</li>
        <li>Type-level state machines</li>
      </ul>
      <h3>Code Example</h3>
      <pre><code class="language-typescript">// Simplified JSON Parser
type Trim&lt;S&gt; = S extends ` ${infer R}` | `\n${infer R}` ? Trim&lt;R&gt; : S;
type ParseString&lt;S&gt; = S extends `"${infer C}"${infer R}` ? [C, R] : never;
type ParseLiteral&lt;S&gt; = S extends `true${infer R}` ? [true, R]
  : S extends `false${infer R}` ? [false, R]
  : S extends `null${infer R}` ? [null, R] : never;

type ParseValue&lt;S&gt; = Trim&lt;S&gt; extends `"${string}` ? ParseString&lt;Trim&lt;S&gt;&gt;
  : Trim&lt;S&gt; extends `{${string}` ? ParseObject&lt;Trim&lt;S&gt;&gt;
  : ParseLiteral&lt;Trim&lt;S&gt;&gt;;

type ParseObject&lt;S&gt; = S extends `{${infer C}}${infer R}` ? [ParsePairs&lt;C&gt;, R] : never;

type ParsePairs&lt;S, Acc = {}&gt; = Trim&lt;S&gt; extends ''
  ? Acc
  : Trim&lt;S&gt; extends `"${infer K}":${infer After}`
    ? ParseValue&lt;After&gt; extends [infer V, infer R]
      ? Trim&lt;R&gt; extends `,${infer Next}`
        ? ParsePairs&lt;Next, Acc &amp; { [P in K]: V }&gt;
        : Acc &amp; { [P in K]: V }
      : Acc
    : Acc;

type ParseJSON&lt;S extends string&gt; = ParseValue&lt;S&gt; extends [infer R, any] ? R : never;

// Usage!
type Parsed = ParseJSON&lt;'{"name": "Alice", "active": true}'&gt;;
// { name: "Alice" } &amp; { active: true }</code></pre>
      <div class="resources"><h4>üìö Learning Resources</h4><ul class="res-list">
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/06228-extreme-json-parser/README.md">Type Challenges - JSON Parser</a><span class="desc">The ultimate challenge</span></li>
        <li><a href="https://github.com/gvergnaud/hotscript">HotScript</a><span class="desc">Type-level parsing utilities</span></li>
      </ul></div>
      <div class="exercises"><h4>üèãÔ∏è Hands-On Exercises</h4><ul>
        <li><a href="https://typehero.dev/challenge/json-parser">JSON Parser</a><span class="ex-diff ex-extreme">Extreme</span><span class="ex-src">TypeHero</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/06228-extreme-json-parser/README.md">JSON Parser</a><span class="ex-diff ex-extreme">Extreme</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00151-extreme-query-string-parser/README.md">Query String Parser</a><span class="ex-diff ex-extreme">Extreme</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/02949-hard-objectfromentries/README.md">Object From Entries</a><span class="ex-diff ex-hard">Hard</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/08640-medium-number-range/README.md">Number Range</a><span class="ex-diff ex-medium">Medium</span><span class="ex-src">Type Challenges</span></li>
        <li><a href="https://github.com/codemix/ts-sql">Build a SQL Parser (ts-sql)</a><span class="ex-diff ex-extreme">Extreme</span><span class="ex-src">ts-sql</span></li>
      </ul></div>
    </article>

    <section class="quick-ref">
      <h2>üöÄ Essential Resources</h2>
      <ul>
        <li><span class="icon">ü¶∏</span><div><a href="https://typehero.dev"><span class="title">TypeHero</span></a><span class="url">Interactive challenges with instant feedback</span></div></li>
        <li><span class="icon">üìù</span><div><a href="https://github.com/type-challenges/type-challenges"><span class="title">Type Challenges</span></a><span class="url">150+ challenges from easy to extreme</span></div></li>
        <li><span class="icon">üéì</span><div><a href="https://type-level-typescript.com"><span class="title">Type-Level TypeScript</span></a><span class="url">Interactive course</span></div></li>
        <li><span class="icon">üé¨</span><div><a href="https://totaltypescript.com"><span class="title">Total TypeScript</span></a><span class="url">Matt Pocock's tutorials</span></div></li>
        <li><span class="icon">üìñ</span><div><a href="https://effectivetypescript.com"><span class="title">Effective TypeScript</span></a><span class="url">83 ways to improve</span></div></li>
        <li><span class="icon">üß™</span><div><a href="https://www.typescriptlang.org/play"><span class="title">TypeScript Playground</span></a><span class="url">Experiment interactively</span></div></li>
        <li><span class="icon">Œª</span><div><a href="https://gcanti.github.io/fp-ts/"><span class="title">fp-ts</span></a><span class="url">FP with HKT patterns</span></div></li>
        <li><span class="icon">üîß</span><div><a href="https://github.com/millsp/ts-toolbelt"><span class="title">ts-toolbelt</span></a><span class="url">200+ type utilities</span></div></li>
        <li><span class="icon">üî•</span><div><a href="https://github.com/gvergnaud/hotscript"><span class="title">HotScript</span></a><span class="url">Type-level parsing</span></div></li>
      </ul>
    </section>
  </div>
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
  <script>
    // Add copy buttons to all code blocks
    document.addEventListener('DOMContentLoaded', function() {
      const copyIcon = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>';
      const checkIcon = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" /></svg>';
      
      // Fallback copy function that works without Clipboard API
      function copyToClipboard(text) {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed';
        textarea.style.left = '-9999px';
        textarea.style.top = '-9999px';
        document.body.appendChild(textarea);
        textarea.focus();
        textarea.select();
        
        let success = false;
        try {
          success = document.execCommand('copy');
        } catch (err) {
          console.error('execCommand error:', err);
        }
        
        document.body.removeChild(textarea);
        return success;
      }
      
      document.querySelectorAll('pre[class*="language-"]').forEach(function(pre) {
        // Create wrapper
        const wrapper = document.createElement('div');
        wrapper.className = 'code-wrapper';
        pre.parentNode.insertBefore(wrapper, pre);
        wrapper.appendChild(pre);
        
        // Create copy button
        const btn = document.createElement('button');
        btn.className = 'copy-btn';
        btn.innerHTML = copyIcon + '<span>Copy</span>';
        btn.title = 'Copy to clipboard';
        wrapper.appendChild(btn);
        
        // Add click handler
        btn.addEventListener('click', function() {
          const code = pre.querySelector('code');
          const text = code ? code.textContent : pre.textContent;
          
          // Try modern API first, fallback to execCommand
          const tryClipboard = async () => {
            try {
              if (navigator.clipboard && navigator.clipboard.writeText) {
                await navigator.clipboard.writeText(text);
                return true;
              }
            } catch (e) {
              // Clipboard API failed, try fallback
            }
            return copyToClipboard(text);
          };
          
          tryClipboard().then(function(success) {
            if (success) {
              btn.innerHTML = checkIcon + '<span>Copied!</span>';
              btn.classList.add('copied');
            } else {
              btn.innerHTML = '<span>Failed</span>';
            }
            
            setTimeout(function() {
              btn.innerHTML = copyIcon + '<span>Copy</span>';
              btn.classList.remove('copied');
            }, 2000);
          });
        });
      });
    });
  </script>
</body>
</html>
